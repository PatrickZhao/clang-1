This branch contains changes to libclang to expand functionality to include
support for general compiling and code generation.

Overview of Changes
===================

High-level Compiler API
-----------------------

A C API for high-level interaction with CompilerInstance and CompilerInvocation
is provided in Compiler.h. These APIs are meant to provide a way for C to
invoke *any* compiler action without having to launch a new process. It is
effectively a convenience API.

It is arguable whether this API is useful. Those opposed to its existence will
say:

1) What it is doing is trivial and simple for clients to implement themselves.
2) It offers very little value because it provides very little insight into the
   output of a compiler action.
   
These are valid criticisms! I will defend its existence by saying:

1) It does lower the barrier for API consumption. This API is extremely simple
   to use and doesn't require any direct C++ consumption by C clients. When you
   are working in C, any help is much appreciated.
2) Because the API is trivial, it is simple to implement and maintain. There
   should be very little overhead to keeping the implementation current.
3) It provides a fallback for actions that don't (yet) have a lower-level C
   interface.
4) It is convenient to launch the compiler without spawning a new process. This
   is handy for platforms where new processes aren't cheap (e.g. Windows). And,
   you save the startup costs of all the new clang executable instances. This
   can add up when you are invoking the compiler frequently.

Code Generation API
-------------------

A C API into compiler code generation actions is provided. It is lower level
than the compiler API and gives you an API for interacting with the results of
the action. This API is provided by CodeGen.h.

This API is effectively a wrapper around clang::EmitBackendOutput(). It behaves
very similarly to the frontend actions defined in llvm::clang::CodeGenAction.

Common libclang functionality split out into common.h
-----------------------------------------------------

Since it didn't make sense to add this new functionality to Index.h nor did I
feel it appropriate to add yet more content to a renamed .h file, I split out
common functionality from Index.h into common.h. This means Index.h is now more
specific to code indexing.

This involved some minor changes to the Doxygen groupings to allow for the
existence of a parent CLANGC group with everything else derived from that
(previously CINDEX was the parent).

This change might have disturbed the hornets nest as far as the composition
of the C API goes. See the open issues section below.

Feature Justification
=====================

My ultimate goal with this feature is to foster development of more tools
utilizing Clang and the benefits that a compiler-as-a-library brings.
There is a large market that prefers consuming C to C++ (e.g. programming
languages that have FFI libraries, such as Python). By exposing an
easier-to-use (and stable) compiling API to these tools, we lower the
barrier to producing tools and this naturally results in more tools being
created. These tools form a rising tide which lifts all ships.

After this work is complete, I would like to update the official Python binding
to integrate with the compiler APIs. But, the C API comes first, so that is
where the focus will be.

Open Issues
===========

I'm a Clang N00b
----------------

This is my first experience hacking on Clang. I probably made some invalid
assumptions and failed to identify gotchas in the proposal. That's where the
community can step in and help me get things right.

High-level Compiler API Design
------------------------------

Should the high-level compiler API distinguish CompilerInvocation and
CompilerInstance APIs or should it roll them into 1? Today, there is a strong
case for merging because there is little functionality on each. However, as
functionality is eventually added, it quickly becomes desirable to separate
things. Do we design for the future or is the API flexible?

CompilerInstance Usability
--------------------------

CompilerInstance.h has a warning in ExecuteAction: "No other CompilerInstance
state should have been initialized (this is an unchecked error)." What does
that mean? Are CompilerInstance instances relying on global state? Can only
one truly exist at one time? Can multiple instances exist over the course of
a program? An LLVM context?

Existing libclang Naming and Structure
--------------------------------------

Existing functions in Index.h assume that the Index API is the only Clang C API
in town. With the introduction of the compiler interfaces, I'm proving that
wrong. Functions like clang_getFile(), which accepts a CXTranslationUnit as the
first parameter, need to be renamed to reflect their module-specific nature.
(Remember that C doesn't have the parameter validation facilities of C++ and
most of the types in the C API are typedefs to void *.) Furthermore, a bunch of
existing C types are prefixed with "CX" (the "X" meaning "Index"). These types
aren't index-specific, so the names need to change.

It seems unavoidable that the C API needs to be refactored with more concern
for future compatibility and reusability of components in multiple modules. In
other words, generic components in the C API shouldn't assume they are
affiliated with a specific module (like Indexing) unless they are given module-
specific names. I recommend splitting components into module-specific .h files
and adopting a per-module naming convention, like clang_<module>_<func> (e.g.
clang_diagnostics_getDiagnosticFromSet()).

Unfortunately, this would break the C API in multiple places. I'm not sure what
Clang's versioning policies are, but this type of change wouldn't come lightly.
Ideally we'd form a clean break from the existing API. But, we could provide
backwards compatibility for a limited time if needed.

The problem only gets worse over time: Clang devs will need to spend more
effort to refactor the API and the growing C API consumer base will
collectively become louder in their ire at the C API refactorings. Since the
C API is supposed to be stable over time, I vote for dealing with the pain now
before it grows any further. But, I'm not a Clang developer, so I'll heed to
the community. Just know that the refactoring to support code generation will
involve lots of code moving and could result in some awkward code.

Code Generation Output Handling
-------------------------------

What's the best way to handle output from code generation? Currently, the 
designed C API only provides a mechanism to buffer to an in-memory object.
Ideally, I'd like the output generation to be configurable and to support
streaming. That would mean creating a wrapper for llvm::raw_ostream and the
derived classes. This would be flexible at a slight increase in complexity.

I suppose we can always provide multiple APIs for code generation: 1 to output
to an in-memory object and another to support controllable output.

Compiler API Resource Path Handling
-----------------------------------

Should the compiler API be accepted, there is an open issue on how to handle
default resource paths. See the TODO in Compiler.h.